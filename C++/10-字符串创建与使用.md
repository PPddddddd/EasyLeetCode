## 字符串

### 字符串定义

字符串就是连续的一连串字符，在 C++当中， 处理字符串的方式有两种类型。一种来自于 C 语言，也被称为 C 风格字符串。另外一种是基于`string`类库。

C 风格的字符串其实就是字符存储在 char`数组`当中。不过它和一般的数组有一些区别，拥有一些特殊的性质。比如一空字符`\0`结尾，它的 ascii 码是 0，用来标记字符串的结尾。

```C++
char str[5] = {'h', 'e', 'l', 'l', 'o'};
char str2[5] = {'h', 'e', 'l', 'l', '\0'};
```

对于上面的两个例子，第一个例子虽然也是 char 数组，但是由于它的结尾不是`\0`，所以它不能看成是字符串。因为很多算法都是以`\0`的位置为标记的，比如计算字符串长度的算法，以及 cout 等等。

上面我们采用的是数组常规的初始化方式，这当然是可以的，不过这样会很不方便。一个是需要一位一位地填写字符，会非常地麻烦。另外还需要手动填充`\0`，也容易忘记，所以对于字符串而言我们还有更好的初始化方式：

```C++
char hello[6] = "hello";
char world[] = "world";
```

用引号括起来的字符串隐式地包含了结尾的`\0`，需要注意的是，我们在确定数组长度的时候需要将结尾的`\0`也计算在内。

这里要提醒大家注意引号的区别， 在 C++当中单引号表示单个字符，而双引号表示字符串。所以下面这种写法是错误的：

```C++
char c = "S";
```

并且“S”其实表示的是字符串所在的内存地址，当我们把一个内存地址赋值给一个`char`类型的时候自然就会报错了。

咦，不是说好的是字符串么，怎么又扯到地址了？不要急，等后面讲到指针的地方就明白了。

### 字符串的读入

直接用字符串常量来初始化字符数组只是一种方式，另外一种常用的方式是只定义字符数组的长度，从外部读入数据，如：

```C++
char str[100];

scanf("%s", str);
cin >> str;
```

无论是使用`scanf`还是`cin`，都是一样的效果。

但是没有这么简单，比如我们再来看一段代码：

```C++
char name[100];
char level[100];

scanf("%s", name);
scanf("%s", level);
```

在这段代码当中，我们定义了 name 和 level 两个字符串变量。当我们执行的时候，就会发现问题：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gvmpp92pz8j611q034wep02.jpg)

我刚输入完名字，还没来得及输 level 就结束了。如果我们把 name 和 level 分别输出的话就会发现，name 的值是 liang，level 的值是 tang。

这说明了什么？说明了我们读入字符串的时候它并不是按行读入的，而是按照空格分隔的！它不像是隔壁的 Python，input 默认就是读入一行，C++的读入默认都是按照空白字符分隔的，除了空格之外，也包括`\t`，空字符等等。

那问题来了，假如我们需要读入一行应该怎么办呢？也有办法，我们可以使用`cin.getline`代替之前的`scanf`或者是`cin`。我们来看下它的函数签名：

```C++
istream& getline ( istream& is, string& str, char delim );
istream& getline ( istream& is, string& str );
```

C++允许参数列表不同的同名函数重载，这两个签名都是 OK 的。两者的差别在于第三个参数，但三个参数表示分隔符，如果不传的话，默认是`'\n'`。第二个参数表示字符串的长度，所以如果要按照行来读入字符串的话，刚刚的代码应该写成：

```C++
cin.getline(name, 100);
cin.getline(level, 100);
```

除了可以使用 getline 之外，还可以使用 get。get 有好几种变体，一种变体是读入一个字符，它有一种变体也可以读入一行字符串。不过唯一的区别是，get 函数不会处理行尾的换行符。如果我们要读入两行字符的话，需要手动将这个换行符处理掉。

```C++
cin.get(name, 100);	// 读入一行数据
cin.get();			// 读入换行符
cin.get(level, 100);// 读入第二行数据
```

写成三行看起来有些繁琐，我们还可以进行简化，简化成一行：

```C++
cin.get(name, 100).get().get(level, 100);
```

看起来很像是 Java8 的流式编程，能够这样做的原因是 get 和 getline 函数会返回一个 cin 的对象。所以我们可以这样连续调用。

相信有些同学已经注意到了，同样的函数名，根据我们传入的参数不同执行了不同的逻辑。这在 C++当中叫做函数重载，是一个非常重要的概念。

### 排坑

关于 getline 有一个比较大的坑，当我们同时使用 cin 和 getline 的时候，有时候会出现问题。比如下面这段代码：

```C++
int a;
char name[100];
cin >> a;
cin.getline(name, 100);

cout << "a = " << a << endl;
cout << "name = " << name << endl;
```

这段代码很简单，我们定义了两个变量。一个是`int`型的 a，一个是字符串 name。我们使用 cin 读入 a，使用 getline 读入 name。

这看起来一点问题也没有，但是当我们运行的时候就会出现问题。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gvnu7prx5vj610w054t8x02.jpg)

会发现我都没有来得及输入 name，程序就结束了，而 name 读到了一个空。

这并不是 C++有 bug，而是我们在输入 32 的时候，敲了一个回车。所以在使用 getline 读入一行的时候，看到了回车，直接退出了，读入了一个空行，这就是为什么我们没有机会输入 name 的原因。

要解决这个问题怎么办呢？其实也很简单，我们额外读入一个字符，把换行符给读取掉就行了。

```C++
int a;
char name[100];
cin >> a;
cin.get(); // getchar() C语言版本
cin.getline(name, 100);

cout << "a = " << a << endl;
cout << "name = " << name << endl;
```

类似的问题在竞赛的题目当中很常见，我们经常要同时读入字符串和数字，很容易遇到这样的问题。遇到了不要紧张，仔细检查一下数据和逻辑，看看是不是读入到了换行符。
