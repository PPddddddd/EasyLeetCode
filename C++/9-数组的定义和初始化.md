### 数组

数组其实也是一种数据格式，不过是一种复合类型，它可以存储多个同类型的值。

使用数组可以将同类型的变量整合起来管理，比如说我们现在要记录三个同学的考试得分。我们当然可以写成`int a1, a2, a3;`，看起来也不会很麻烦。但如果我们有 50 个同学呢？如果有 5000 个同学呢？显然就不能通过这种方式了，何况每个变量都要起一个独一无二的名字，这也很麻烦。

使用数组就不会有这样的问题，我们只需要规定数组的长度，通过一个变量就可以存储任意多个值。有 5000 个同学就写成`int scores[5000];`就都能存下了。

定义一个数组只需要三个要素：变量类型、数组名、数组长度即可。

```C++
typename arrayName[arraySize];
```

有一点需要注意，`arrayName`的类型不是数组，而是`typename`数组。也就是说数组也是区分类型的，这也是 C++中的数组和 Python 中 List 的区别之一。

### 数组的使用

#### 元素访问

对于一个数组来说，当我们需要访问其中的元素时，可以通过下标的方式来访问。

在绝大多数计算机程序当中，数组的下标通常都是从 0 开始的。第一个数存在第 0 位，第二个数存在第 1 位，以此类推。下标通过方括号表示，如：

```C++
cout << arrayName[0] << endl;
```

注意，我们传入的下标不能大于等于数组的长度（由于是从 0 开始的），编译器往往不会报错，只会给出一个警告，但运行的过程当中可能会引发各种意想不到的问题。因为很可能你访问的内存已经超过了程序管理的范围，访问到了一些操作系统内存或者是其他禁止访问的内存，引起难以想象的后果。

```C++
int a[3];
cout << a[10] << endl;
```

在上面的例子当中，我们声明了一个长度为 3 的数组，但是访问了下标 10。这显然超出了数组的范围，但是当我们编译的时候编译器并不会报错，只会抛出一个警告。要知道程序员往往是看不见警告的。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gvm48y48tcj61h00820to02.jpg)

如果一不小心就会错过这个信息，导致潜在的风险。所以在访问之前一定要切记，确保下标在数组的范围内。

#### 初始化

数组和其他变量一样，也可以在声明的时候进行初始化。

最常见的方式是将它的每一个元素的值写出来：

```C++
int a[3] = {0, 1, 2};
```

编译器会将花括号当中的元素一个一个地填到数组对应的位置当中，花括号当中的元素数量并不一定需要和数组长度相等，如果小于数组长度，那么就会初始化对应数量的元素。

```C++
int a[3] = {0, 1};
```

那么数组 a 的前两位会被初始化成 0 和 1，第三位会默认初始化为 0。

如果想要将数组当中所有元素都初始化成 0，则比较特殊，我们只需要写一个 0 即可。

```C++
int a[100] = {0};
```

但只有初始化成 0 的时候可以这么操作，如果传入其他值，则不会生效。

还有一种初始化方式是我们不填数组的长度，而通过初始化的方式让编译器替我们去算：

```C++
int a[] = {0, 1, 2, 3, 4};
```

编译器通过执行初始化知道 a 数组的长度为 5，不过 C++ primer 强烈建议我们不用这么干。因为我们人工数出来的结果可能和编译器不一样（我们会犯错），增加我们 debug 的难度。

#### C++11 的初始化方式

C++11 当中对于数组的初始化又有了一些新的定义，首先是可以省略等号：

```C++
int a[3] {1, 2, 3};
```

其次花括号内可以留空，这等价于将元素全部设置为 0：

```C++
int a[100] = {};
int b[10] {};
```

列表初始化时禁止缩窄转化，我们在上一篇文章当中讲过：

```C++
char cs[4] = {0, 0x3f3f3f3f, 'a', 'z'};		// 禁止，因为0x3f3f3f3f超过了char范围
```
